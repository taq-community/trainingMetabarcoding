---
title: Formation au métabarcoding avec BARQUE
title-slide-attributes:
  data-background-image: img/bg.jpg
  data-background-opacity: "0.2"
subtitle: De l'assurance qualité à l'assignation taxonomique
format:
  revealjs:
    self-contained: true
    logo: img/logo.png
    theme: dark
    css: style.css
    highlight-style: dracula
    slide-number: true
author:
  - name: Steve Vissault
    orcid: 0000-0002-0866-4376
    email: steve.vissault@inrs.ca
    affiliations: Institut National de la Recherche Scientifique (INRS)
date: last-modified
code-copy: true
---

## Objectifs de la formation

::: {.callout-note}
La présentation est disponible à l'adresse: [https://taq.info/trainingMetabarcoding/](https://taq.info/trainingMetabarcoding/)
:::

:::{.incremental}
1. **Comprendre le séquençage Illumina** et les fichiers FASTQ
2. **Manipuler des données de séquençage** avec R
3. **Découvrir BARQUE**, un pipeline de métabarcoding québécois
4. **Appliquer les concepts** sur des exemples pratiques
:::


---

## Avant de commencer

### Installation des librairies R requises

1. Ouvrir RStudio 
2. Envoyer les commandes suivantes dans la console

```{r install-packages}
#| echo: true
#| eval: false

# Installation des packages Bioconductor
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(c("ShortRead", "Biostrings", "Rqc"))
install.packages(c("parallel"))
```

# Introduction {background-image="img/bg.jpg" background-opacity="0.3"}

## Introduction

![](img/diagram.png)

---

## Comment le séquencage est effectué?

:::: {.columns}

::: {.column width="35%"}
![Crédit: J. Couillard](img/illumina.jpeg)
:::

::: {.column width="65%"}
![DOI: 10.1016/B978-0-12-802234-4.00002-1](img/sequencing.jpg)
:::

::::  

---

## Comment le séquencage est effectué?

:::: {.columns}
::: {.column width="35%"}
:::{.callout-note}
- Chaque nucléotide à un fluorophore spécifique (4 canaux). 
- Certains appareils (ex. NextSeq) vont utiliser deux canaux car c'est plus rapide et moins coûteux. 
:::
:::
::: {.column width="65%"}
![DOI: 10.1016/B978-0-12-802234-4.00002-1](img/sequencing.jpg)
:::
::::

Le signal renvoyé par le laser est traduit en chromatographe pour chaque amplicon séquencé.


---

## Comment le séquencage est effectué?

### Exemple de chromatographe

![Source: LabXchange.org](img/labxchange-1.jpg)


---

## Comment le séquencage est effectué?

### Exemple de chromatographe


:::: {.columns}
::: {.column width="30%"}
:::{.callout-important}
Le score est basé sur:

- La séparation entre les clusters (pureté du signal)
- Le rapport signal/bruit
- La distribution de l'intensités des 4 canaux
- La position dans le read (la qualité diminue généralement vers la fin)
:::
:::
::: {.column width="70%"}
![Source: wikipedia.org](img/Phred_Figure_1_cropped.jpg)
:::
::::

# Les fichiers FASTQ {background-image="img/bg.jpg" background-opacity="0.3"}
Les sortie du séquenceur Illumina 

---

## Fichiers de sortie du séquenceur Illumina

Exemple de nomenclature de fichier de sortie du séquenceur Illumina: `sample1_1_L001_R1_001.fastq.gz`
 
. . .

|             | Signification                | Exemple              |
|-------------|------------------------------|----------------------|
| **sample1** | Identifiant de l'échantillon | sample1, sample2     |
| **\_1**     | Numéro de réplicat           | 1, 2, 3...           |
| **L001**    | Numéro de ligne / lane:      | L001-L008            |
| **R1/R2**   | Direction de lecture         | R1=avant, R2=arrière |
| **001**     | Segment de fichier           | 001, 002...          |

. . .

:::{.callout-note}
- **Séquençage paired-end** = fichiers R1 + R2 pour chaque échantillon avec l'ensemble des amplicons.
- **Numéro de Ligne ou *lane*** =  Une flowcell Illumina est divisée en plusieurs voies physiques parallèles où le séquençage se déroule simultanément.
:::

---

## Structure du fichier FASTQ

Contient plusieurs lignes dont **un ensemble de 4 lignes correspond à un amplicon**.

```{r fastq-structure-12lines}
#| echo: true
#| cache: true
system.file(package="ShortRead", "extdata/E-MTAB-1147/ERR127302_1_subset.fastq.gz") |> 
  gzfile() |> 
  readLines(n = 12)
```

---

## Structure du fichier FASTQ

```{r fastq-structure-4lines}
#| echo: true
#| cache: true
system.file(package="ShortRead", "extdata/E-MTAB-1147/ERR127302_1_subset.fastq.gz") |> 
  gzfile() |> 
  readLines(n = 4)
```

:::{.incremental}
1. **Ligne [1]** : Identifiant de séquence (commence par `@`)
2. **Ligne [2]** : Séquence d'ADN (A, T, G, C) de l'amplicon
3. **Ligne [3]** : Séparateur (`+`)
4. **Ligne [4]** : Scores de qualité (un par base)
:::


---

## Ligne d'identification

Décomposition de l'identifiant

```
@SH00321:6:BWR98207-2813:1:1101:1065:1015 1:N:0:AACCATAGAA+GGCGAGATGG
```

- **SH00321** : ID de l'instrument
- **6** : Numéro d'exécution
- **BWR98207-2813** : ID de la flowcell
- **1:1101:1065:1015** : Tuile et coordonnées X:Y
- **1:N:0** : Numéro de lecture, flag de filtre, bits de contrôle
- **AACCATAGAA+GGCGAGATGG** : Codes-barres d'échantillon (double indexation)

::: {.notes}
Ce sont les codes-barres (barcodes/index) utilisés pour identifier l'échantillon, pas pour amplifier l'ADN.
:::

---

## Interprétation des scores de qualité


Exemple de chaine de caractères donnant le score de qualité (1 caractère par nucléotide): `GGGGGGGGGGGGGGGGGGGGGGGG9GG-G9G9G9GGGG`


| Caractère ASCII | Score Phred | Taux d'erreur | Précision |
|:---------------:|:-----------:|:-------------:|:---------:|
|       `G`       |     38      |    0,016%     |  99,984%  |
|       `9`       |     24      |     0,40%     |  99,60%   |
|       `-`       |     12      |     6,31%     |  93,69%   |

:::{.callout-tip}
**Règle générale** : Q30 ou plus = haute qualité (99,9% de précision)
:::


---

## Scores de qualité du séquencage

Les scores de qualité utilisent l'encodage ASCII.

```
 Quality encoding: !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHI
                   |         |         |         |         |
    Quality score: 0........10........20........30........40   
```

## Scores de qualité du séquencage

Avec R, comment convertir l'encodage ASCII en score de Phred et en probabilité d'obtenir une erreur (précision)?

```{r quality-conversion}
#| echo: true
#| output-location: slide
#| cache: true
# Convertir la chaîne de qualité en scores Phred
quality_string <- "GGGGGGG99GG-GGG"
quality_scores <- as.integer(charToRaw(quality_string)) - 33

# Afficher la correspondance
data.frame(
  Caractere = strsplit(quality_string, "")[[1]],
  Score_Phred = quality_scores,
  Precision = paste0(round((10^(-quality_scores/10)) * 100, 2), "%")
)
```

# Manipuler des fichiers FASTQ {background-image="img/bg.jpg" background-opacity="0.3"}


---

## Lire un fichier FASTQ avec R

```{r read-fastq}
#| echo: true
#| cache: true

# Lire le fichier FASTQ
fq <- system.file(package="ShortRead", "extdata/E-MTAB-1147/ERR127302_1_subset.fastq.gz") |> ShortRead::readFastq()

# Examiner la structure
fq
```

---

## Extraire les informations principales

```{r extract-info}
#| echo: true
#| cache: true

# Nombre d'amplicons
length(fq)

# Extraire les amplicons
sequences <- ShortRead::sread(fq)

# Extraire les identifiants
ids <- ShortRead::id(fq)

# Extraire les scores de qualité
qualities <- Biostrings::quality(fq)

# Premier identifiant et séquence
ids[1]
sequences[1]
```

---

## Résumé statistique d'un fichier FASTQ

```{r fastq-summary}
#| echo: true
#| cache: true

# Longueur des séquences
seq_lengths <- Biostrings::width(sequences)
summary(seq_lengths)

# Distribution des scores de qualité
qual_matrix <- as(qualities, "matrix")
mean_quality <- rowMeans(qual_matrix)
summary(mean_quality)

# Composition en bases
Biostrings::alphabetFrequency(sequences, as.prob = TRUE)[1:4, 1:4]
```

---

## Assurance qualité avec la librairie `Rqc`

```{r quality-analysis-rqc}
#| echo: true
#| cache: true

fq_files <- system.file(package="ShortRead", "extdata/E-MTAB-1147/") |> list.files(full.names = TRUE)
qa <- Rqc::rqcQA(fq_files)
Rqc::rqcCycleQualityPlot(qa)
```

---

## Analyser la qualité du séquencage

### Pourquoi la qualité des lectures décroit au fur et à mesure des itérations?

:::{.incremental}
  1. Dégradation des fluorophores
  2. Accumulation d'erreurs de phase, soit la désynchronisation des clusters
  3. Épuisement des réactifs, compétition pour les nucléotides par exemple
  4. Dommages à l'ADN par stress chimique par exemple
  5. Accumulation de sous-produits (ex. Résidus de réaction s'accumulent)
:::

---

## Pratique - Analysez vos propres données

:::{.callout-note}
**Exercice simple**: Utilisez le code R que nous venons de voir pour analyser vos propres fichiers FASTQ
:::

0. Créer un dossier d'analyse
1. Placez vos fichiers FASTQ dans sous-dossier `data/`
2. Exécutez les chunks (le code des diapos) pour analyser la qualité
3. Comparez les résultats avec les exemples montrés
4. Bonus: Explorer les autres graphiques dans le package `Rqc`

:::{.callout-tip}
Si vous n'avez pas de données, vous pouvez télécharger l'exemple [ici](https://github.com/enormandeau/barque_test_dataset/archive/refs/heads/master.zip). Ce sont 10 échantillons de métabarcoding mitofish-12S
:::

{{< countdown "10:00" >}}

---

## Points clés à retenir

:::{.incremental}
- **FASTQ** = format standard pour les données de séquençage
- **4 lignes par lecture d'amplicon** : ID, lecture de l'amplicon, séparateur, qualité de la lecture
- **Paired-end** : les fichiers R1 et R2 contiennent les lecture d'amplicons à apparier
- **Scores de qualité** : Plus élevé = meilleur (viser Q30+)
- **La qualité se dégrade** vers la fin des lectures (normal)
:::

# Traiter les amplicons séquencés avec BARQUE {background-image="img/bg.jpg" background-opacity="0.3"}

## Qu'est ce que BARQUE?
### Un large éventail d'outils en bioinformatique

![Hakimzadeh et al, 2024](img/Hakimzadeh_et_al_2024.png)

---

## Qu'est ce que BARQUE?

::: {.columns}
::: {.column width="30%"}
![](https://raw.githubusercontent.com/enormandeau/barque/master/00_archive/barque_small.png)
:::
::: {.column  width="70%"}
- Programme écrit par Éric Normandeau (IBIS, ULaval)
- Disponible sur [Github](https://github.com/enormandeau/barque) depuis 2017
- C'est un pipeline de traitement de données de séquences spécialisé sur le *metabarcoding* 
- Il agit comme chef d'orchestre d'un ensemble de programmes
:::
:::

---

## Qu'est ce que BARQUE?

::: {.columns}
::: {.column  width="40%"}
![Creative Commons](img/chef_d'orchestre.jpg)
:::
::: {.column  width="60%"}
- **FLASH** v1.2.11+: fusion des lectures paired-end
- **VSEARCH** v2.14.2+: outil d'analyse de séquences
(version obligatoire)
- **Trimmomatic**: outil de filtrage et découpage des
  lectures 
- **NCBI BLAST**: annotation des séquences
non-correspondantes
- Un ensemble de programmes **UNIX** comme `cut`, `sort`, `uniq` etc. qui manipulent des chaînes de caractères ou des nombres
- **R** & **Python**: Visualisation et synthèse des résultats
:::
:::


# Les grandes étapes de BARQUE {background-image="img/bg.jpg" background-opacity="0.3"}

## Les grandes étapes de BARQUE 

::: {.columns}
::: {.column width="60%"}
![](img/barque_pipeline_simple.png)
:::
::: {.column  width="40%"}
Vue d'ensemble du pipeline de métabarcoding
:::
:::

---

## Étape 1: Validation du projet

::: {.columns}
::: {.column width="60%"}
![](img/barque_pipeline_simple.png)
:::
::: {.column  width="40%"}
- Vérification des fichiers d'entrée
- Validation de la nomenclature : `SampleID_*_R1_001.fastq.gz`
- Vérification des logiciels
- Présence de la base de données correspondante à l'amorce
:::
:::

---

## Étape 2: Nettoyage des données

::: {.columns}
::: {.column width="60%"}
![](img/barque_pipeline_simple.png)
:::
::: {.column  width="40%"}
- Nettoyage des lectures avec Trimmomatic
- Suppression des bases de faible qualité 
- Découpage selon les paramètres définis
- Retrait des amplicons non-appariés
:::
:::

---

## Étape 3: Appariement des lectures

::: {.columns}
::: {.column width="60%"}
![](img/barque_pipeline_simple.png)
:::
::: {.column  width="40%"}
- Appariement des amplicons (R1 + R2) avec FLASH
- Création d'une lecture consensus pour chaque amplicon
- Amélioration de la qualité globale
:::
:::

---

## Étape 4: Séparation des amplicons

::: {.columns}
::: {.column width="60%"}
![](img/barque_pipeline_simple.png)
:::
::: {.column  width="40%"}
Pour chaque lecture fusionnée:

- Recherche du primer forward au début
- Recherche du primer reverse à la fin (complément inverse)
- Calcul de la distance avec les primers de référence
- Vérification de la taille d'amplicon attendue
:::
:::

---

## Étape 5: Retrait des chimères

::: {.columns}
::: {.column width="60%"}
![](img/barque_pipeline_simple.png)
:::
::: {.column  width="40%"}
- Détection des séquences chimériques avec VSEARCH
- Les chimères sont des artefacts de PCR
- Conservation des séquences authentiques
:::
:::

::: {.notes}
Les chimères se forment généralement lors de la PCR lorsque :

- Un amplicon partiellement étendu se détache de sa matrice d'origine
- Ce fragment incomplet s'hybride avec une autre séquence template similaire
- L'extension se poursuit sur cette nouvelle matrice
- Le résultat final est une séquence hybride qui n'existe pas réellement dans l'échantillon biologique
:::

---

## Étape 6: Assignement taxonomique


::: {.columns}
::: {.column width="60%"}
![](img/barque_pipeline_simple.png)
:::
::: {.column  width="40%"}
- Attribution des espèces via la bases de données correspondante à l'amorce
- Utilisation de BOLD (COI), MitoFish (12S), etc.
- Génération des tables d'occurrence par espèce
:::
:::

--- 

## Télécharger BARQUE
### Pratique

Télécharger BARQUE en cliquant [sur le lien](https://github.com/enormandeau/barque/archive/refs/heads/master.zip)

Ou en rendant à l'adresse suivante: [https://github.com/enormandeau/barque](https://github.com/enormandeau/barque)

![](img/github-barque-dl.png)

---

## Les étapes en tant qu'utilisateur

:::{.incremental}
1. On place les fichiers `fastq.gz` avec la bonne nomenclature dans le dossier `04_data`
2. On configure les amorces (P3 et P5) utilisées avec le fichier `02_info/primers.csv`  
3. On ajuste les paramètres du pipeline avec le fichier `02_info/barque_config.sh`
4. On s'assure que la base de données BOLD est téléchargé si on travaille avec les amorces COI.
5. On éxecute le pipeline
:::

. . . 

::: {.callout-tip}
Si vous voulez réutiliser la configuration du pipeline pour d'autres fois, c'est une bonne pratique de dupliquer le fichier et de le sauvegarder sous un autre nom.   
:::

---

## Étape 1 - Placer les fichiers dans `04_data`

On peut faire tout de suite l'étape 1 avec vos données.

::: {.callout-tip}
Si vous avez pas de données, vous pouvez télécharger celles fournies par Éric Normandeau, en [cliquant ici](https://github.com/enormandeau/barque_test_dataset/archive/refs/heads/master.zip). Ce sont 10 échantillons de métabarcoding mitofish-12S, chacun.
:::

---

## Étape 2 - Configuration des amorces

### On configure les amorces (P3 et P5)  

- Ouvrir le fichier `02_info/primers.csv` 

![](img/primers.png)

- Retirer le symbole `#` pour la ligne correspondante à votre amorce
- **Laisser le symbole `#` sur les autres lignes**

---

## Étape 3 - Ajustements des paramètres du pipeline

::: {.columns}
::: {.column width="70%"}
```plain
# Modify the following parameter values according to your experiment
# Do not modify the parameter names or remove parameters
# Do not add spaces around the equal (=) sign
# It is a good idea to try to run Barque with different parameters 

# Global parameters
NCPUS=20                    # Number of CPUs to use. A lot of the steps are parallelized (int, 1+)
PRIMER_FILE="02_info/primers.csv" # File with PCR primers information

# Skip data preparation and rerun only from vsearchp
SKIP_DATA_PREP=0            # 1 to skip data preparation steps, 0 to run full pipeline (recommended)

# Filtering with Trimmomatic
CROP_LENGTH=200             # Cut reads to this length after filtering. Just under amplicon length

# Merging reads with flash
MIN_OVERLAP=30              # Minimum number of overlapping nucleotides to merge reads (int, 1+)
MAX_OVERLAP=280             # Maximum number of overlapping nucleotides to merge reads (int, 1+)

# Extracting barcodes
MAX_PRIMER_DIFF=8           # Maximum number of differences allowed between primer and sequence (int, 0+)

# Running or skipping chimera detection
SKIP_CHIMERA_DETECTION=0    # 0 to search for chimeras (RECOMMENDED), 1 to skip chimera detection
                            #   or use already created chimera cleaned files

# vsearch
MAX_ACCEPTS=20              # Accept at most this number of sequences before stoping search (int, 1+)
MAX_REJECTS=20              # Reject at most this number of sequences before stoping search (int, 1+)
QUERY_COV=0.6               # At least that proportion of the sequence must match the database (float, 0-1)
MIN_HIT_LENGTH=100          # Minimum vsearch hit length to keep in results (int, 1+)

# Filters
MIN_HITS_SAMPLE=10          # Minimum number of hits in at least one sample to keep in results (int, 1+)
MIN_HITS_EXPERIMENT=20      # Minimum number of hits in whole experiment to keep in results (int, 1+)

# Non-annotated reads
NUM_NON_ANNOTATED_SEQ=200   # Number of unique most-frequent non-annotated reads to keep (int, 1+)

# Multiple hits
MIN_DEPTH_MULTI=10          # Min depth to report unique reads per sample in multiple hit reports

# OTUs
SKIP_OTUS=1                 # 1 to skip OTU creation, 0 to use it
MIN_SIZE_FOR_OTU=20         # Only unique reads with at least this coverage will be used for OTUs
```
:::
::: {.column  width="30%"}
On ajuste les paramètres du pipeline dans le fichier `02_info/barque_config.sh`

::: {.callout-tip}
Pour déterminer le nombre de coeur sur votre ordinateur, utiliser la commande R suivante
`parallel::detectCores() - 2`
:::
:::
:::

---

## Étape 4 - Base de données par type d'amorces

BARQUE utilise différentes bases de données selon le type d'amorces utilisé pour l'amplification:

::: {.columns}
::: {.column width="50%"}
**Bases de données intégrées:**

- **MitoFish** (12S rRNA): Séquences mitochondriales de poissons
- **BOLD** (COI): Base de données génétiques du code-barres de la vie
- **SILVA** (18S rRNA): Séquences ribosomales eucaryotes
- **Bases personnalisées**: Possibilité d'ajouter vos propres bases

:::
::: {.column width="50%"}
**Formats requis:**

- Fichiers FASTA avec headers normalisés
- Taxonomie incluse dans le header
- Placement dans `03_databases/`

:::
:::

---

## Étape 4 - Télécharger des base de données 
### BOLD (COI) et SILVA (18S)

Les bases de données BOLD et SILVA pré-formatées pour BARQUE sont disponibles ici:

[https://www.ibis.ulaval.ca/services/bioinformatique/barque_databases/](https://www.ibis.ulaval.ca/services/bioinformatique/barque_databases/)

:::{.callout-important}
**Après téléchargement, renommer le fichier en `silva.fasta.gz`** ou `****.fasta.gz`** et le placer dans `03_databases/`
:::
---

## Comment VSEARCH assigne la taxonomie?

VSEARCH utilise une approche de **similarité de séquences** basée sur l'alignement global:

:::{.incremental}
1. **Recherche de similarité**: Chaque séquence inconnue est alignée contre toutes les séquences de la base de données
2. **Algorithme d'alignement global**: Utilise un algorithme de type Needleman-Wunsch optimisé pour comparer les séquences (`MAX_ACCEPTS`, `MAX_REJECTS`)
3. **Calcul de score de similarité**: Pourcentage d'identité basé sur les positions qui correspondent (matches)
4. **Filtrage des résultats**: Application des seuils de qualité (`QUERY_COV`, `MIN_HIT_LENGTH`)
5. **Attribution taxonomique**: La séquence est assignée à toutes les espèces ayant un score supérieur au seuil de similarité établie.
:::

---

## Paramètres clés de VSEARCH

Dans le fichier `barque_config.sh`, ces paramètres contrôlent l'assignement:

#### Qualité de l'assignation

```bash
QUERY_COV=0.6       # Couverture minimale de la requête (60% de la séquence)
MIN_HIT_LENGTH=100  # Longueur minimale d'alignement pour conserver le résultat
```

#### Profondeur de la recherche

```bash
MAX_ACCEPTS=20      # Nombre maximal de correspondances acceptées avant d'arrêter
MAX_REJECTS=20      # Nombre maximal de rejets avant d'arrêter la recherche
```


:::{.callout-tip}
**QUERY_COV=0.6** signifie qu'au moins 60% de votre séquence doit correspondre à une séquence de la base de données pour être considérée comme un match valide
:::

---

## Exemple d'assignement avec VSEARCH

::: {.columns}
::: {.column width="50%"}
**Séquence inconnue:**

```
ATCGATCGATCGATCG...
(150 nucléotides)
```

**Meilleure correspondance dans la base:**

- **Espèce**: *Salmo salar* (Saumon atlantique)
- **Similarité**: 98.5%
- **Couverture**: 95%
:::

::: {.column width="50%"}
**Critères de validation:**

- Similarité > seuil (généralement 97-99%)
- Couverture > QUERY_COV (60%)
- Longueur alignement > MIN_HIT_LENGTH (100 bp)
- Nombre d'occurrences > MIN_HITS_SAMPLE (10)

**Résultat:**
L'amplicon est assigné à *Salmo salar* avec un niveau de confiance élevé
:::
:::

---

## Gestion des correspondances multiples

Que se passe-t-il si plusieurs espèces ont le même score?

:::{.incremental}
- **Correspondance unique** (1 hit): Attribution directe à l'espèce
- **Correspondances multiples** (>1 hits au même score):
  - BARQUE conserve tous les hits ayant le score maximal
  - Création d'un fichier séparé pour les hits multiples
  - L'utilisateur doit décider comment traiter ces ambiguïtés
- **Aucune correspondance**: La séquence est rapportée comme "non-annotée" et peut être analysée avec BLAST
:::

:::{.callout-warning}
Les correspondances multiples peuvent indiquer:

- Des espèces très proches génétiquement
- Une résolution insuffisante du marqueur génétique
- Un besoin de validation supplémentaire
:::


# Utiliser docker pour executer BARQUE {background-image="img/bg.jpg" background-opacity="0.3"}

## Pourquoi utiliser docker

BARQUE requière plusieurs programmes qui ne sont pas tous compatibles avec l'environnement Windows

![Hakimzadeh et al, 2024](img/Hakimzadeh_et_al_2024-2.png)

---

## Comment docker fonctionne?

::: {.columns}
::: {.column width="70%"}
Docker crée un environnement isolé (conteneur) qui contient:

- Tous les programmes requis par BARQUE
- Les bonnes versions des dépendances
- Un système Linux compatible

Le conteneur peut accéder aux fichiers de votre ordinateur via des volumes montés.
:::
::: {.column  width="30%"}
:::{.callout-tip}
Docker permet d'utiliser BARQUE sur Windows, Mac ou Linux sans installer manuellement tous les programmes requis
:::
:::
:::

---

## Comment docker fonctionne?

![@Soroosh Nazem](img/docker_kitchen.jpeg){width="90%"}

---

## La recette
### Déclaration de l'image docker

```plain
# Base image with Ubuntu
FROM ubuntu:24.04

# Update and install essential packages
RUN apt-get update && apt-get install -y \
    wget \
    curl \
    build-essential \
    software-properties-common \
    default-jre \
    parallel \
    r-base \
    bc \
    python3-setuptools \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# Install FLASH (v1.2.11+)
RUN wget https://github.com/dstreett/FLASH2/archive/refs/tags/2.2.00.tar.gz && \
    tar -xzf 2.2.00.tar.gz && \
    cd FLASH2-2.2.00 && \
    make && \
    mv flash2 flash && \
    cp flash /usr/local/bin && \
    cd .. && rm -rf FLASH2-2.2.00 2.2.00.tar.gz

# Install VSEARCH v2.14.2+
RUN wget https://github.com/torognes/vsearch/releases/download/v2.30.0/vsearch-2.30.0-linux-x86_64.tar.gz && \
    tar -xzf vsearch-2.30.0-linux-x86_64.tar.gz && \
    cp vsearch-2.30.0-linux-x86_64/bin/vsearch /usr/local/bin && \
    rm -rf vsearch-2.30.0-linux-x86_64*

# Default shell
CMD ["/bin/bash"]
```

---

## Étape 1: Télécharger l'image Docker

Ouvrir un terminal (MacOS) ou PowerShell (Windows) exécuter la commande suivante pour télécharger l'image BARQUE:

```bash
docker pull steveviss/barque:latest
```

Cette commande télécharge l'image Docker contenant BARQUE et tous ses programmes requis (FLASH, VSEARCH, Trimmomatic, etc.)

:::{.callout-note}
Le téléchargement peut prendre quelques minutes selon votre connexion Internet
:::

---

## Étape 2: Exécuter l'image Docker en mode interactif

Pour lancer BARQUE dans un conteneur Docker avec accès à vos fichiers:

```bash
# Pour macOS
docker run -it -v /chemin/vers/barque:/barque steveviss/barque:latest

# Pour Windows
docker run -it -v C:\chemin\vers\barque:/barque steveviss/barque:latest
```

:::{.callout-important}
**Remplacer `/chemin/vers/barque`** par le chemin absolu vers votre dossier BARQUE local
:::

. . .

**Explication des options:**

- `-it` : Mode interactif avec terminal
- `-v /chemin/vers/barque:/barque` : Monte votre dossier local dans le conteneur
- `steveviss/barque:latest` : L'image Docker à utiliser

---

## Étape 3: Exécuter BARQUE dans le conteneur Docker

Une fois dans le conteneur Docker, vous êtes dans un environnement Linux avec BARQUE prêt à l'emploi:

```bash
# Naviguer vers le dossier BARQUE
cd /barque

# Lancer BARQUE avec votre fichier de configuration
./barque 02_info/barque_config.sh
```
. . .

Pour quitter le conteneur:
```bash
exit
```

# Extra {background-image="img/bg.jpg" background-opacity="0.3"}

## Application Shiny

### Exécuter BARQUE de manière embarqué


![](img/barque-embarquée.png)

Application disponible à l'adresse suivante: [https://cloud.taq.info](https://cloud.taq.info), contacter moi pour un accès: steve.vissault@inrs.ca

---

## Application Shiny
### Exécuter BARQUE de manière embarqué

![](img/barque-embarquée-2.png)

Application disponible à l'adresse suivante: [https://cloud.taq.info](https://cloud.taq.info), contacter moi pour un accès: steve.vissault@inrs.ca


---

## Rapport de metabarcoding

### Obtenir le rapport sur les résultats de BARQUE


::: {.columns}
::: {.column width="60%"}
![](img/metabarcoding_report.png)
:::
::: {.column  width="40%"}
- Le rappport est disponible et executable depuis la librairie [barqueReport sur Github](https://github.com/taq-community/barqueReport)
- Accès à la [documentation](https://taq.info/barqueReport/)
:::
:::


---

## Rapport de metabarcoding
### Installation de barqueReport

Vous pouvez installer la version de développement de barqueReport depuis [GitHub](https://github.com/) avec :
```{r}
#| echo: true
#| eval: false
install.packages("remotes")
remotes::install_github("taq-community/barqueReport")
```

---

## Rapport de metabarcoding
### Générer un rapport de métabarcoding

La fonction principale génère un rapport HTML interactif à partir des résultats du pipeline BARQUE:
```{r}
#| echo: true
#| eval: false
library(barqueReport)

# Sélection interactive du dossier BARQUE et du fichier de qualité Illumina
generate_metabarcoding_report(
  barque_output_folder = file.choose(),  # Sélectionner le dossier de sortie barque
  samples_ids = c("ST1", "ST2", "ST3", "ST4"),
  title = "Étude du Lac Supérieur",
  subtitle = "",
  author = "Steve Vissault, Julie Couillard & Tuan Ahn To",
  illumina_quality_file = file.choose(),  # Sélectionner le fichier Quality_Metrics.csv
  blank_lab = "LAB_BLANK",
  blank_field = "FIELD_BLANK"
)
```
